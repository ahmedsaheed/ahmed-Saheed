import define1 from "./e93997d5089d7165@2303.js";

function _intro(md){return(
md`# Sorting Algorithm

### Bubble Sort

It is the simplest of all sorting algorithms but very slow.(not advisable for large dataset).

The rules of this algorithms are as follows.

- Compare only two indexes at a time starting at the index beginning
- If the LHS is greater than the RHS SWAP positions else do nothing
- Then, move one position to the right and repeat the previous step.
- At each stage of the iteration, the largest or greatest element must be on the extreme end of the RHS.
- Finally repeat all step.
`
)}

function _codeblock(md){return(
md`~~~java
// IMPLEMENTATION IN JAVA
 static void bubbleSort(int[] arr) {
	int temp = 0;
	for(int i=0; i < arr.length; i++){
		for(int j=1; j < (arr.length - i); j++){
		if(arr[j-1] > arr[j]){
//swap elements
			temp = arr[j-1];
			arr[j-1] = arr[j];
			arr[j] = temp;
			} // if close
		} // inner for loop close
	} // outer for loop close
} // end of method

//Time Complexity is mostly = 0(n^2)
~~~
`
)}

function _visualIntro(md){return(
md`## Bubble Sort Visualization
You can click the sort button to view the implementation of this algorithm in real time.
`
)}

function _d3(require){return(
require("d3@5")
)}

function _data(size)
{
  var data = []
  for(var i = 0;i < size; i++){
    data.push(Math.floor(Math.random()*100))
  }
  return data
}


function _Arrow(){return(
class Arrow{
  constructor(props){
    Object.keys(props).forEach((key)=>{this[key] = props[key]})
    this.outer = this.element.append("g").attr("transform",`translate(${this.x},${this.y})`)
    this.inner = this.outer.append("g")
    this.inner.append("line")
      .attr("stroke","black")
      .attr("stroke-width",2)
      .attr("y2",30)
    this.inner.append("line")
      .attr("stroke","black")
      .attr("stroke-width",2)
      .attr("x2",-8)
      .attr("y2",10)
    this.inner.append("line")
      .attr("stroke","black")
      .attr("stroke-width",2)
      .attr("x2",8)
      .attr("y2",10)    
  }
  setX(x,duration,ease){
    this.x = x
    return this.outer.transition().duration(duration).ease(ease).attr("transform",`translate(${this.x},${this.y})`)
  }
}
)}

async function* _dataset(d3,DOM,Arr,data,count)
{
  var svg = d3.select(DOM.svg(900,90)).attr("style","background:white;border:0px solid black")
  var outer = svg.append("g").attr("transform",`translate(20,20)`)
  var arr = new Arr({element:outer,x:0,y:0,data:data})
  var entries = arr.array
  
  yield svg.node()
  var duration = 500
  var swap = true
  while(swap && count > 0){
      swap = false
      for(var i = 0;i < data.length - 1;i++){
        entries[i].setFill("tomato",duration)
        entries[i].setDatumFill("white",duration)
        entries[i+1].setFill("tomato",duration)
        await entries[i+1].setDatumFill("white",duration).end()
        if(entries[i].datum > entries[i+1].datum){
          await arr.swap(i,i+1,duration,d3.easeBounceOut).end()
          swap = true
        }
        entries[i].setFill("white",duration)
        entries[i].setDatumFill("black",duration)
        entries[i+1].setFill("white",duration)
        entries[i+1].setDatumFill("black",duration)
      }
  }
  if(count > 0){
      entries.map(entry => {
        entry.setFill("olivedrab",duration)
        entry.setDatumFill("white",duration)
      } )
    }
}


function _size(slider){return(
slider({max:50,step:1,description:"Manipulate the size of array"})
)}

function _b(button){return(
button({value:"sort"})
)}

function _Entry(){return(
class Entry{
  constructor(props){
    Object.keys(props).forEach((key)=>{this[key] = props[key]})
    this.outer = this.element.append("g").attr("transform",`translate(${this.x},${this.y})`)
    this.inner = this.outer.append("g")
    this.square = this.inner.append("rect")
      .attr("width",30)
      .attr("height",30)
      .attr("stroke","black")
      .attr("fill",this.fill)
    this.text = this.inner.append("text")
      .text(this.datum)
      .attr("font-size",20)
      .attr("text-anchor","middle")
      .attr("x",15)
      .attr("y",22)
      .attr("fill",this.datumFill)
 }
  setFill(fill,duration){
    this.fill = fill
    return this.square.transition().duration(duration).attr("fill",this.fill)
  }
  setDatumFill(datumFill,duration){
    this.datumFill = datumFill
    return this.text.transition().duration(duration).attr("fill",this.datumFill)
  }
  setX(x,duration,ease){
   this.x = x
   return this.outer.transition().duration(duration).ease(ease).attr("transform",`translate(${this.x},${this.y})`)
  }
  setY(y,duration,ease){
   this.y = y
   return this.outer.transition().duration(duration).ease(ease).attr("transform",`translate(${this.x},${this.y})`)
  }
  
}
)}

function _Arr(Entry){return(
class{
  constructor(props){
    Object.keys(props).forEach((key)=>{this[key] = props[key]})
    this.outer = this.element.append("g").attr("transform",`translate(${this.x},${this.y})`)
    this.inner = this.outer.append("g")
    this.array = []
    for(var i = 0;i<this.data.length;i++){
      this.array.push(new Entry({element:this.inner,x:30*i,y:0,fill:"white",datumFill:"black",datum:this.data[i]}))
    } 
 }
  swap(i,j,duration,ease){
        var start = +new Date()
    var temp = this.array[i]
    this.array[i] = this.array[j]
    this.array[j] = temp
    
    temp = this.array[i].x
    this.array[i].setX(this.array[j].x,duration,ease)
    return this.array[j].setX(temp,duration,ease)
        var end = +new Date()
    var result = end - start;
    console.log(result)

  }
  
}
)}

function _count(){return(
-1
)}

function _14(b,$0)
{
  b
  $0.value++
}


function _15(size,$0)
{
  size
  $0.value = 0
}


export default function define(runtime, observer) {
  const main = runtime.module();
  main.variable(observer("intro")).define("intro", ["md"], _intro);
  main.variable(observer("viewof codeblock")).define("viewof codeblock", ["md"], _codeblock);
  main.variable(observer("codeblock")).define("codeblock", ["Generators", "viewof codeblock"], (G, _) => G.input(_));
  main.variable(observer("visualIntro")).define("visualIntro", ["md"], _visualIntro);
  const child1 = runtime.module(define1);
  main.import("slider", child1);
  main.import("button", child1);
  main.import("select", child1);
  main.import("text", child1);
  main.import("radio", child1);
  main.import("checkbox", child1);
  main.import("number", child1);
  main.variable(observer("d3")).define("d3", ["require"], _d3);
  main.variable(observer("data")).define("data", ["size"], _data);
  main.variable(observer("Arrow")).define("Arrow", _Arrow);
  main.variable(observer("dataset")).define("dataset", ["d3","DOM","Arr","data","count"], _dataset);
  main.variable(observer("viewof size")).define("viewof size", ["slider"], _size);
  main.variable(observer("size")).define("size", ["Generators", "viewof size"], (G, _) => G.input(_));
  main.variable(observer("viewof b")).define("viewof b", ["button"], _b);
  main.variable(observer("b")).define("b", ["Generators", "viewof b"], (G, _) => G.input(_));
  main.variable(observer("Entry")).define("Entry", _Entry);
  main.variable(observer("Arr")).define("Arr", ["Entry"], _Arr);
  main.define("initial count", _count);
  main.variable(observer("mutable count")).define("mutable count", ["Mutable", "initial count"], (M, _) => new M(_));
  main.variable(observer("count")).define("count", ["mutable count"], _ => _.generator);
  main.variable(observer()).define(["b","mutable count"], _14);
  main.variable(observer()).define(["size","mutable count"], _15);
  return main;
}
